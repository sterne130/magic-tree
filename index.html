<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>wishful winter</title>
    <!-- 使用 tailwindcss 的国内/通用 CDN -->
    <script src="https://cdn.jsdelivr.net/npm/tailwindcss@3.4.1/lib/index.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* --- 1. 基础设置 --- */
        body { margin: 0; overflow: hidden; background: #050103; font-family: 'Helvetica Neue', 'Segoe UI', sans-serif; }
        #canvas-container { position: absolute; width: 100%; height: 100%; z-index: 1; }
        .mirror { transform: scaleX(-1); }

        /* --- 2. 文艺感标题 (Wishful Winter) --- */
        .artistic-title {
            font-family: Georgia, 'Times New Roman', serif; /* 衬线字体 */
            font-style: italic; /* 斜体 */
            font-weight: 400; 
            letter-spacing: 0.05em; 
            text-transform: lowercase; /* 强制小写 */
            /* 柔和流光 */
            background: linear-gradient(90deg, #ffb6c1, #ffffff, #ffb6c1);
            background-size: 200% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: shimmer 6s linear infinite;
            filter: drop-shadow(0 0 10px rgba(255, 105, 180, 0.4));
        }
        
        @keyframes shimmer {
            to { background-position: 200% center; }
        }

        /* 呼吸灯点 */
        .status-dot {
            width: 4px; height: 4px;
            background-color: #ff69b4;
            border-radius: 50%;
            box-shadow: 0 0 8px #ff69b4, 0 0 12px #ff1493;
            animation: breathe 3s infinite ease-in-out;
            opacity: 0; transition: opacity 1s 1s;
        }
        @keyframes breathe {
            0%, 100% { transform: scale(0.8); opacity: 0.5; }
            50% { transform: scale(1.4); opacity: 1; }
        }

        /* --- 3. 加载层样式 --- */
        #loading-overlay {
            position: fixed; inset: 0; background: #050103; z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 1.2s ease-out;
        }
        /* 细致的圆环加载 */
        .loader-ring {
            width: 40px; height: 40px;
            border: 2px solid rgba(255, 105, 180, 0.1);
            border-top: 2px solid #ff69b4;
            border-radius: 50%;
            animation: spin 1s linear infinite; margin-bottom: 25px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>

    <!-- Import Map (换用 jsdelivr，国内访问更稳) -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
            "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
        }
    }
    </script>
</head>
<body>

    <!-- 1. 加载层 -->
    <div id="loading-overlay">
        <div class="loader-ring"></div>
        <h1 class="artistic-title text-xl">wishful winter</h1>
        <div class="text-white/30 text-xs mt-3 font-mono tracking-widest" id="status-text">locating local files...</div>
        
        <!-- 错误提示区 -->
        <div id="error-msg" class="hidden mt-6 text-red-300 text-xs text-left p-4 border border-red-900 bg-red-900/20 rounded max-w-md"></div>
        
        <button id="start-btn" class="hidden mt-8 px-10 py-2 border border-pink-500/30 text-pink-300 hover:bg-pink-500/10 hover:text-white transition-all rounded-sm text-xs tracking-[0.2em] uppercase duration-500">
            Enter
        </button>
    </div>

    <!-- 2. 主界面 UI (完全符合要求：左上角，小写，字号缩小，文艺) -->
    <div class="fixed top-8 left-8 z-10 pointer-events-none select-none mix-blend-screen">
        <!-- 从 text-4xl 改为 text-2xl md:text-3xl，视觉更精致 -->
        <h1 class="artistic-title text-2xl md:text-3xl">wishful winter</h1>
        <div class="flex items-center mt-2 opacity-80">
            <div class="w-8 h-[1px] bg-gradient-to-r from-pink-400/50 to-transparent"></div>
            <div id="live-dot" class="status-dot -ml-1"></div>
        </div>
    </div>

    <!-- 摄像头盒子 -->
    <div id="cam-box" class="fixed bottom-6 right-6 w-32 h-24 sm:w-40 sm:h-28 border border-white/10 rounded overflow-hidden bg-black/80 z-40 hidden shadow-[0_0_30px_rgba(255,105,180,0.1)]">
        <video id="webcam" autoplay playsinline class="w-full h-full object-cover mirror opacity-30 mix-blend-lighten grayscale"></video>
        <canvas id="output_canvas" class="absolute inset-0 w-full h-full object-cover mirror"></canvas>
    </div>

    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, HandLandmarker, DrawingUtils } from '@mediapipe/tasks-vision';

        const CONFIG = {
            colors: { bg: 0x050103, pinkMain: 0xFF69B4, pinkGlow: 0xFF1493 },
            counts: { leavesPink: 3600, leavesWhite: 400, ribbon: 1200 }
        };

        const ui = {
            status: document.getElementById('status-text'),
            startBtn: document.getElementById('start-btn'),
            error: document.getElementById('error-msg'),
            overlay: document.getElementById('loading-overlay'),
            loader: document.querySelector('.loader-ring'),
            liveDot: document.getElementById('live-dot')
        };

        // --- 1. AI 自动初始化 (严格本地模式) ---
        let handLandmarker = undefined;

        async function initAI() {
            // 设置一个超时检查，如果15秒还没好，提示用户缺文件
            const timer = setTimeout(() => {
                if(ui.loader.style.display !== 'none') {
                    ui.error.innerHTML = "⚠️ <strong>加载超时 (Timeout)</strong><br>系统无法在您的 GitHub 仓库中找到 AI 核心文件。<br><br>请检查仓库是否包含以下 <strong>3个文件</strong> (缺一不可):<br>1. <code>hand_landmarker.task</code><br>2. <code>vision_wasm_internal.wasm</code><br>3. <code>vision_wasm_internal.js</code>";
                    ui.error.style.display = 'block';
                    ui.status.innerText = "files missing";
                }
            }, 15000);

            try {
                ui.status.innerText = "loading local engine...";
                
                // 【关键】使用 ./ 强制读取本地文件
                // 这要求您的 index.html 同级目录下必须有 vision_wasm_internal.wasm 和 vision_wasm_internal.js
                const vision = await FilesetResolver.forVisionTasks("./");
                
                ui.status.innerText = "loading local model...";
                
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: "./hand_landmarker.task", 
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 1
                });

                // 加载成功
                clearTimeout(timer);
                ui.status.innerText = "ready";
                ui.loader.style.display = 'none';
                ui.startBtn.style.display = 'block';

            } catch(err) {
                clearTimeout(timer);
                console.error(err);
                ui.status.style.display = 'none';
                ui.loader.style.display = 'none';
                
                let msg = err.message || "Unknown Error";
                // 智能分析错误原因
                if(msg.includes("404")) msg = "找不到文件 (404 Not Found)。<br>请检查 GitHub 仓库是否上传了 .task 或 .wasm 文件。";
                else if(msg.includes("fetch")) msg = "文件读取失败。<br>可能是文件名大小写错误，或者文件未上传成功。";
                
                ui.error.innerHTML = "<strong>Error:</strong><br>" + msg;
                ui.error.style.display = 'block';
            }
        }

        ui.startBtn.addEventListener('click', () => {
            ui.overlay.style.opacity = 0;
            // 激活主界面的呼吸灯
            setTimeout(() => {
                ui.overlay.style.display = 'none';
                if(ui.liveDot) ui.liveDot.style.opacity = 1; 
            }, 1200);
            startCam();
        });

        initAI();

        // --- 2. 3D 场景 (保持原样) ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(CONFIG.colors.bg);
        scene.fog = new THREE.FogExp2(CONFIG.colors.bg, 0.035);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 2, 24); 

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ReinhardToneMapping;
        container.appendChild(renderer.domElement);

        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.1; 
        bloomPass.strength = 1.4; 
        bloomPass.radius = 0.7;
        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        scene.add(new THREE.AmbientLight(0xffffff, 4.0));
        const spotLight = new THREE.SpotLight(CONFIG.colors.pinkMain, 100);
        spotLight.position.set(10, 20, 10);
        scene.add(spotLight);
        scene.add(new THREE.PointLight(0x8A2BE2, 40, 50));

        // Geometry Helpers
        const getTreePos = (n, h, r, yOff) => {
            const a = new Float32Array(n*3);
            for(let i=0;i<n;i++) {
                const y=(Math.random()-0.5)*h, relY=(y+h/2)/h, rad=(1-relY)*r*Math.sqrt(Math.random()), ang=Math.random()*6.28;
                a.set([rad*Math.cos(ang),y+yOff,rad*Math.sin(ang)],i*3);
            }
            return a;
        };
        const getExpPos = (n, r) => {
            const a = new Float32Array(n*3);
            for(let i=0;i<n;i++) {
                const rad=r*Math.cbrt(Math.random()), th=Math.random()*6.28, ph=Math.acos(2*Math.random()-1);
                a.set([rad*Math.sin(ph)*Math.cos(th),rad*Math.sin(ph)*Math.sin(th),rad*Math.cos(ph)],i*3);
            }
            return a;
        };
        const getRibPos = (n, h, r, t, yOff) => {
            const a = new Float32Array(n*3);
            for(let i=0;i<n;i++) {
                const p=i/n, y=(p-0.5)*h, rad=(1-p)*r+0.2, ang=p*6.28*t;
                a.set([rad*Math.cos(ang),y+yOff,rad*Math.sin(ang)],i*3);
            }
            return a;
        };

        class Sys {
            constructor(cnt, geo, mat, fn1, fn2) {
                this.m = new THREE.InstancedMesh(geo, mat, cnt);
                this.p1 = fn1(); this.p2 = fn2(); this.cp = new Float32Array(this.p1);
                this.d = new THREE.Object3D(); this.cnt = cnt;
                scene.add(this.m);
            }
            upd(dt, t, s) {
                this.m.rotation.y += s.rot * dt;
                const tgt = s.mode === 'TREE' ? this.p1 : this.p2;
                for(let i=0; i<this.cnt; i++) {
                    const x=i*3;
                    this.cp[x]+=(tgt[x]-this.cp[x])*0.1;
                    this.cp[x+1]+=(tgt[x+1]-this.cp[x+1])*0.1;
                    this.cp[x+2]+=(tgt[x+2]-this.cp[x+2])*0.1;
                    this.d.position.set(this.cp[x],this.cp[x+1],this.cp[x+2]);
                    const sc = Math.sin(t*2+i)*0.2+0.8;
                    this.d.scale.set(sc,sc,sc);
                    this.d.updateMatrix();
                    this.m.setMatrixAt(i,this.d.matrix);
                }
                this.m.instanceMatrix.needsUpdate=true;
            }
        }

        const sys1 = new Sys(3600, new THREE.OctahedronGeometry(0.12), new THREE.MeshStandardMaterial({color:0xFF69B4, emissive:0xFF1493, emissiveIntensity:0.7, roughness:0.2, metalness:0.1}), ()=>getTreePos(3600,13,4.5,-2), ()=>getExpPos(3600,12));
        const sys2 = new Sys(400, new THREE.BoxGeometry(0.15,0.15,0.15), new THREE.MeshStandardMaterial({color:0xFFFFFF, emissive:0x555555}), ()=>getTreePos(400,13,4.5,-2), ()=>getExpPos(400,14));
        const sys3 = new Sys(1200, new THREE.TetrahedronGeometry(0.08), new THREE.MeshStandardMaterial({color:0xFFFFFF, emissive:0xFFFFFF}), ()=>getRibPos(1200,14,5,5,-2), ()=>getExpPos(1200,15));

        // --- 五角星 ---
        const starShape = new THREE.Shape();
        for(let i=0; i<10; i++) {
            const r = i % 2 === 0 ? 0.8 : 0.4;
            const a = i / 5 * Math.PI;
            starShape.lineTo(Math.sin(a)*r, Math.cos(a)*r);
        }
        const starGeo = new THREE.ExtrudeGeometry(starShape, { depth: 0.2, bevelEnabled: true, bevelThickness: 0.1 });
        const starMat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, emissive: 0xFFFFFF, emissiveIntensity: 2.5, roughness: 0.1 });
        const star = new THREE.Mesh(starGeo, starMat);
        star.position.y = 7; 
        scene.add(star);

        const clock = new THREE.Clock();
        const state = { mode:'TREE', rot:0, targetRot:0.2, time:0 };

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            state.time += dt;
            state.rot += (state.targetRot - state.rot) * dt * 2;
            sys1.upd(dt, state.time, state);
            sys2.upd(dt, state.time, state);
            sys3.upd(dt, state.time, state);
            
            star.rotation.y += dt;
            star.rotation.z = Math.sin(state.time)*0.1;
            
            const targetScale = state.mode==='TREE'?1:0.01;
            const currentScale = star.scale.x;
            const newScale = currentScale + (targetScale - currentScale) * dt * 5;
            star.scale.set(newScale, newScale, newScale);
            
            composer.render();
        }
        animate();

        // --- Camera ---
        const video = document.getElementById('webcam');
        const canvas = document.getElementById('output_canvas');
        const ctx = canvas.getContext('2d');
        let lastTime = -1;

        function startCam() {
            document.getElementById('cam-box').style.display = 'block';
            navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => {
                video.srcObject = stream;
                video.addEventListener("loadeddata", predict);
            });
        }

        function predict() {
            if (!handLandmarker) return;
            if (video.currentTime !== lastTime) {
                lastTime = video.currentTime;
                const res = handLandmarker.detectForVideo(video, performance.now());
                canvas.width = video.videoWidth; canvas.height = video.videoHeight;
                ctx.clearRect(0,0,canvas.width,canvas.height);
                if (res.landmarks[0]) {
                    const lm = res.landmarks[0];
                    new DrawingUtils(ctx).drawConnectors(lm, HandLandmarker.HAND_CONNECTIONS, {color:"#FF1493", lineWidth:3});
                    state.mode = Math.hypot(lm[4].x-lm[8].x, lm[4].y-lm[8].y) < 0.1 ? 'TREE' : 'EXPLODE';
                    state.targetRot = (lm[9].x-0.5)*4;
                }
            }
            requestAnimationFrame(predict);
        }
        
        window.addEventListener('resize', ()=>{
            camera.aspect=window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth,window.innerHeight);
            composer.setSize(window.innerWidth,window.innerHeight);
        });
    </script>
</body>
</html>
